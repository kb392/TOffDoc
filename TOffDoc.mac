cpwin;
/* toffdocxml.mac                                           */
/* Библотека создания офисных документов на основе шаблонов */
Import rslx;
import globals;
import rcw;
import rsexts;
import "info-zip.d32";
import "constxml.mac";

/* проверка терминального макроса */                                                            
private macro CheckTermTools
    const sMacroName="termtools.mac";
    var src_dt:date, src_tm:time, src_size:integer;
    var dst_dt:date=Date(0,0,0), dst_tm:time=Time(0,0,0), dst_size:integer=0;

    var strDstPath="$MAC\\"+sMacroName;

    var ErrCode;
    var strTermMacTemplatePath="..\\MAC\\USER_MAC\\.TERMINAL";
    GetRegistryValue("USER_MAC\\ДИРЕКТОРИИ\\МАКРОСЫ ДЛЯ ТЕРМИНАЛА",V_STRING, strTermMacTemplatePath, ErrCode);

    var strSrcPath=strTermMacTemplatePath+"\\" + sMacroName;

    if (GetFileInfo(strSrcPath, @src_dt, @src_tm, @src_size))
        GetFileInfo(strDstPath, @dst_dt, @dst_tm, @dst_size);
        if ((src_dt!=dst_dt) and (src_tm!=dst_tm) or (src_size!=dst_size))
            if (not CopyFile (strSrcPath, strDstPath))
                MsgBox("Ошибка копирования макроса на терминал");
            end;
        end;
    else
        MsgBox("Не найден эталон терминального макроса "+strSrcPath);
    end;
end;//macro CheckTermTools 


private macro XML_EscapeSting(s)
    if (ValType(s)==V_UNDEF) return ""; end;
    /*
    s = StrSubst ( s, "&", "&amp;");
    s = StrSubst ( s, "<", "&lt;");
    s = StrSubst ( s, "<", "&gt;");
    s = StrSubst ( s, "'", "&apos;");
    s = StrSubst ( s, "\"", "&quot;");
    */
    return String(s);
end; /* macro XML_EscapeSting */

/* базовый класс */
class TBaseXmlDoc(strTemplate_)
    var DOMDOC;
    var strFormPath=strTemplate_;
    var strFolder=strTemplate_;
    var strBaseName:String;
    var strWorkDir:String;
    var strFormFolder:String;
    var strFormName:String;
    var strFormExt:String;
    var Verbose=true;          //!!!
    var bRemoveOnServer=false; //!!!    /* Удалять промежуточный файл на сервере         */
    var strTemplate;              /* Путь к файлу шаблона                          */
    var InitOk;                   /* Флаг успешной инициализации                   */         
    var strReportName:String;     /* Имя файла отчета, если не заполнится, UID     */
    var aZipFiles=TArray();       /* Массив имён файлов для распаковки/запаковки   */
    var AutoOpen:Bool=true;       /* Открывать файл после формирования             */
    var AutoPrint=false;          /* Флаг автоматической печати на def принтер     */

    macro DebugPrint(s)
        if (Verbose)
            PrintLn(s);
        end;
    end; /* macro DebugPrint */

    
    macro GetDirUID
        return "odtxml"+GetApplicationKey();
        //return "odtxml"+String(date())+String(Time());
    end; /* macro GetDirUID */

    
    macro LoadXml(xmlDoc, strFile)
        if (not xmlDoc.Load(strWorkDir+"\\"+strFile))
            PrintLn("Error load XML: "+strWorkDir+"\\"+strFile);
            xmlDoc=null;
            return false;
        end;
        return true;
    end;


    private macro InArray(a,v)
        var i:integer=0;
        if (ValType(a)!=V_GENOBJ) return false; end;
        while(i<a.Size)
            if(a(i)==v) return true; end;
            i=i+1;
        end;
        return false;
    end; /* macro InArray */


    macro UnZipFile()
        var strFileName;
        //var zipFile=OpenZip(strTemplate);
        var strZipItemName:String;
        var strDst;
        var iZipErr:Integer;

        if (not MakeDir (strWorkDir))
            MsgBox("can not create "+strWorkDir);
            return false;
        end;

        var i;
        for (i,1,Parmcount()-1,1)
            GetParm(i, strFileName);
            aZipFiles[aZipFiles.Size]=strFileName; //запоминаем имена распакованных файлов для последующей запаковки

            strFileName=StrSubst(strFileName,"\\","/"); // in zip folder/folder/folder/file
            iZipErr=izUnzip(strTemplate, strWorkDir+"\\", strFileName);
            if(iZipErr)
                MsgBox("Ошибка "+String(iZipErr)+" при распаковки файла "+strFileName+" из архива "+strTemplate+" в "+strWorkDir);
                return false;
            end;
        end;

        return true;

    /* */
    onerror(er)
        msgbox(er.Message + " (строка " + er.line + ")");
        return false;
    /*    */
    end; /* UnZipContent */

    /*
    macro GetXPathItems(strXPath, elem)

        /*if (DOMDOC.documentElement==NullVal)
            return false;
        end;*/

        if (ValType(elem)==V_UNDEF)
            elem=domDoc.documentElement;
        end;

        var domNodes=elem.selectNodes(strXPath);
        return domNodes;
    end; //macro GetXPath

    macro GetXPath(strXPath, elem)

        /*if (oXML.documentElement==NullVal)
            return false;
        end;*/

        if (ValType(elem)==V_UNDEF)
            elem=domDoc.documentElement;
        end;

        var domNodes=elem.selectNodes(strXPath);
        if (domNodes.Length>0)
            return Trim(domNodes.item(0).text);
        end;

        return "";
    end; //macro GetXPath
    */

    macro SetReportName(s)
        strReportName=s;
    end;

    macro ConvertOnServer(sNewFormat, sPath, sDestPath)
        var sParams;
        var sEXE="..\\Tools\\LibreOfficePortable\\LibreOfficeWriterPortable.exe";
        //var sEXE="..\\Tools\\LibreOfficePortable\\App\\LibreOffice\\program\\sWriter.exe";

        if (ValType(sDestPath)==V_UNDEF)
            sDestPath=SplitFile(sPath);
            If  (substr(sDestPath, strlen(sDestPath))== "\\")
                sDestPath=SubStr(sDestPath,1,StrLen(sDestPath)-1);
            End;
            
        end;

        sParams="--headless --convert-to "+sNewFormat + "  --outdir \""+sDestPath+"\" \""+sPath+"\"";
        PrintLn(sEXE+" "+sParams);
        //Run(sEXE, sParams, ">", null);
        StartProg(sEXE, sParams, false);
    end;
    
    macro DocSave(strTermDst:@String)
        var iZipErr;

        if ((ValType(strReportName)==V_UNDEF) or (strReportName==""))
            strReportName=strBaseName;
        end;

        var zipFilePath=strWorkDir+"\\" +strReportName+strFormExt;
        if (not CopyFile (strTemplate, zipFilePath))
            PrintLn("Ошибка копирования "+strTemplate+"->"+zipFilePath);
            return false;
        end;

        var strFile;
        for(strFile, aZipFiles)
            iZipErr=izZip(strReportName+strFormExt, strWorkDir, strFile);
            if(iZipErr)
                MsgBox("Ошибка " + String(iZipErr) + " при добавлении " + strFile+ " в " + strReportName+strFormExt + " в "+strWorkDir );
                return false;
            else
                RemoveFile(strWorkDir+"\\"+strFile);
            end;
        end;


        var sDstPath; //2015.11.13
        if ((ValType(strTermDst)==V_STRING) and (strTermDst!=""))
        //считаем, что передан путь и будем сохранять в него
            If  (substr(strTermDst, strlen(strTermDst))!= "\\")
                strTermDst=strTermDst+ "\\";
            End;
            strTermDst=strTermDst+strReportName+strFormExt;
            sDstPath=strTermDst;
        else
        //считаем, что путь не передан. копируем на терминал
            //при копировании файлов на терминал они попадают в папку 
            CheckTermTools();
            strTermDst=CallRemoteRsl ("termtools.mac", "GetIniString", "UPDIR",".\\RSEXTT.INI");
            if ((strTermDst!="") and (SubStr(strTermDst,StrLen(strTermDst))!="\\"))
                strTermDst=strTermDst+"\\";
            end;
            /* Копирование на терминал */
            strTermDst=strTermDst+strReportName+strFormExt;
            sDstPath="$"+strTermDst;
        end;

        if (CopyFile(zipFilePath, sDstPath))
            if (bRemoveOnServer)
               RemoveFile(zipFilePath);
               RemoveDir(strWorkDir);
            end;
            //DebugPrint("Файл перемещен на терминал");
            return true;
        else
            PrintLn("Ошибка переноса " + zipFilePath + " -> " + sDstPath);
        end;
        return false;

    end; //DocSave


    macro DocConstructor()

        strFormFolder=SplitFile (strFormPath, strFormName, strFormExt);
        strBaseName=GetDirUID();
        strWorkDir=GetSysDir(0)+strBaseName;
        strFolder=strFormName;

        strTemplate="..\\Templs\\user_mac\\"+strFormName + strFormExt;

        /* */

        DOMDOC = ActiveX("MSXML.DOMDocument");

        DOMDoc.async = False;

    end; //macro DocConstructor

    DocConstructor();

end; //class TBaseXmlDoc


class (TBaseXmlDoc) TOpenDocForm(strFormPath_)
    //var DOMDOC;
    //var strFolder=strFormPath;
    //var strBaseName:String;       /* Имя отчета, длинная бестолковая фигня         */
    var strDefTableName="Таблица1";/* Имя таблицы                                   */
    var strTableName;             /* Имя таблицы                                   */
    var domTableNode;             /* Объект Таблица, если используется             */
    var iTableFooterRows=0;       /* Строк в хвосте таблицы после строки-образца, 
                                    если они есть надо проинициализировать до вызова таблицы  */
    var domNewRowNode;            /* Объект Образцовая строка                      */
    var iRow;                     /* Содержит счетчик строк в текущей Таблице      */
    var domRow;                   /* Временная переменная для сохранения ссылки    */ 
                                  /* на строку в Таблице которая будет заполняться */
    var bSaveCalled:Bool=false;   /* Флаг вызова метода Save                       */ 
    var Printer;                  /* Принтер для печати, отличный от умолчального  */
    var strSectionName="Раздел1"; /* Имя раздела-шаблона                           */
    var strSectionBaseName:String;/* Имя раздела-шаблона                           */
    var domSectionNode;           /* Объект раздел, если используется              */
    var domSectionNewNode;        /* Объект раздел-шаблон                          */
    var iSection=0;               /* Счётчик разделов                              */
    var aSectionFields;           /* Названия полей, зависимых от раздела          */
    /* var domUserFieldDecl;         /* */*/



    /* Является ли данная переменная зависимой от контекста раздела */
    macro IsSectionField(strFieldName)
        return InArray(aSectionFields,strFieldName)
    end; /* macro IsSectionField */


    macro Init2(paramInit)

        InitTBaseXmlDoc(paramInit);

        if(not UnZipFile("content.xml"))
            return false;
        end;
        /* */

        if (not LoadXml(DOMDoc, "content.xml"))
            return false;    
        end;

        DOMDoc.setProperty("SelectionLanguage", "XPath");
        DOMDoc.setProperty("SelectionNamespaces", "xmlns:text='urn:oasis:names:tc:opendocument:xmlns:text:1.0' xmlns:office='urn:oasis:names:tc:opendocument:xmlns:office:1.0' xmlns:table='urn:oasis:names:tc:opendocument:xmlns:table:1.0'");
        return true;
    end; /* macro Init2 */
    


    macro SetField(strFieldName, v)
        var strValueType:String;
        var strXmlType:String;
        var strXPath:String;
        var domNodes, domNode;

        if (not InitOk) return false; end;

        if (IsSectionField(strFieldName))
            if (iSection==0)
                MsgBox("Попытка установить зависящую от раздела переменную "+strFieldName+" вне контекста раздела");
                return false;
            end;
            strFieldName=domSectionNode.getAttribute("text:name")+"_"+strFieldName;
        end;

        strXPath="//text:user-field-decl[@text:name='"+strFieldName+"']";
        DebugPrint(strXPath);
        domNodes=DOMDoc.documentElement.selectNodes(strXPath);
        if (domNodes.length==0)
            MsgBox("В шаблоне поле "+strFieldName+" не найдено ");
            return false;
        end;
        domNode=domNodes.Item(0);

        strValueType=domNode.GetAttribute("office:value-type");

        if   ("string"==strValueType)
            strXmlType="string-value";
            if ((ValType(v)==V_UNDEF) or (v==NullVal))
                v="";
            end;
        elif ( "float"==strValueType)
            strXmlType="value";
            if ((ValType(v)==V_UNDEF) or (v==NullVal))
                v="0";
            end;
        else
            strXmlType="value";
            if ((ValType(v)==V_UNDEF) or (v==NullVal))
                v="";
            end;
        end;
        strXmlType="office:"+strXmlType;

        domNode.setAttribute(strXmlType, v);

        //20151116 Если не менять по всему тексту, то LibreOffice открывает нормально, 
        //но M$Word не обновляет, поэтому находим все вхождения поля и меняем
        strXPath="//text:user-field-get[@text:name='"+strFieldName+"']";
        DebugPrint(strXPath);
        domNodes=DOMDoc.documentElement.selectNodes(strXPath);
        var i;
        for (i, 0, domNodes.length-1, 1)
            domNodes.item(i).text=v;
        end;

        onerror(er)
            msgbox(er.Message + " (строка " + er.line + ")|"+"Ошибка установки значения ["+String(v)+"]| поля ["+strFieldName+"]");
            return false;
    end; /* macro SetField */

    macro SetVariable(strFieldName, v)
        var strValueType:String;
        var strXmlType:String;
        var domNodes, domNode;

        if (not InitOk) return false; end;

        domNodes=DOMDoc.documentElement.selectNodes("//text:variable-set[@text:name='"+strFieldName+"']");
        if (domNodes.length==0)
            MsgBox("В шаблоне переменная "+strFieldName+" не найдена ");
            return false;
        end;
        domNode=domNodes.Item(0);

        strValueType=domNode.GetAttribute("office:value-type");

        if   ("string"==strValueType)
            strXmlType="string-value";
        elif ( "float"==strValueType)
            strXmlType="value";
        else
            strXmlType="value";
        end;
        strXmlType="office:"+strXmlType;

        domNode.setAttribute(strXmlType, v);
    end; /* macro SetVariable */



    macro Save(sDestFolder)
        bSaveCalled=True;
        if (not InitOk) return false; end;

        DOMDoc.Save(strWorkDir+"\\content.xml");

        var strTermDst:String;

        if ((ValType(sDestFolder)==V_STRING) and (sDestFolder!=""))
        //режим введён для массового безинтерфейсного формирования файлов     
            var sPath=sDestFolder;
            if (DocSave(@sPath))
                return sPath;
            else
                return "";
            end;
        else
            if (DocSave(@strTermDst) and (AutoOpen or AutoPrint))
                var strArgs:String;
                strArgs=strTermDst;
                if (AutoPrint)
                //печать
                    if ((ValType(Printer)!=V_UNDEF) and (Printer!=""))
                        //на указанный принтер
                        strArgs="-pt " +Printer+ " "+ strArgs;
                    else
                        //на принтер по умолчанию
                        strArgs="-p" + strArgs;
                    end;
                end;
                StartProg ("$"+"swriter", strArgs, true);
            else
                return false;
            end;
        end;
        return true;
    end;



    /* Инициализация таблицы для вывода */
    macro Table(sParamName)
        var strXPath:String;
        var domNodes;

        if (not InitOk) return false; end;

        if ((valtype(sParamName)==V_UNDEF) or (sParamName==""))
            strTableName=strDefTableName;
        else
            strTableName=sParamName;
        end;

        /**/
        if  (ValType(domSectionNewNode)!=V_UNDEF)
        /* Если определён раздел-шаблон, то ищем в нём, если находим, 
           то это повторяющаяся таблица и к её имени надо приписывать имя раздела */
            DebugPrint("Table: section detected");
            strXPath=".//table:table[@table:name='"+strTableName+"']";
            DebugPrint(strXPath);
            domNodes=domSectionNewNode.selectNodes(strXPath);
            DebugPrint("Table: table in section = "+String(domNodes.length));
            if (domNodes.length==1)
                strTableName=domSectionNode.getAttribute("text:name") + " " + strTableName;
                DebugPrint("Table: change ["+sParamName+"] to ["+strTableName+"]");
            end;
        end;
        /**/

        strXPath="//table:table[@table:name='"+strTableName+"']";
        DebugPrint(strXPath);
        domNodes=DOMDoc.documentElement.selectNodes(strXPath);
        if (domNodes.length==0)
            MsgBox("В шаблоне не найдено таблицы "+strTableName+"");
            return false;
        end;
        domTableNode=domNodes.Item(0);
        DebugPrint(domTableNode.nodeName);

        if (iTableFooterRows>0)
            strXPath="table:table-row[last()-"+String(iTableFooterRows)+"]";
        else
            strXPath="table:table-row[last()]";
        end;
        DebugPrint(strXPath);
        domRow=domTableNode.selectNodes(strXPath).Item(0);
        DebugPrint(domRow.nodeName);
        domNewRowNode=domRow.cloneNode(true);
        iRow=0;
    end; /* macro Table */

    /* Записать переданный массив как строку ранее опрделённой таблицы см. Table() */
    macro WriteRow(ar)
        var strXPath:String;
        var i:Integer;
        var domCell;

        if (not InitOk) return false; end;

        if (not IsEqClass ("TArray", ar))    return false; end;
        if (V_UNDEF==Valtype(domTableNode))  Table(); end;
        if (iRow>0)
            if (iTableFooterRows>0)
                domRow=domTableNode.insertBefore(domNewRowNode.cloneNode(true),domTableNode.selectNodes("table:table-row[last()-"+String(iTableFooterRows)+"+1]").Item(0));
            else
                domRow=domTableNode.appendChild(domNewRowNode.cloneNode(true));
            end;
        end;
        for (i, 0, ar.Size-1, 1)
            strXPath="table:table-cell["+String(i+1)+"]/text:p";
            domCell=domRow.selectNodes(strXPath).Item(0);
            DebugPrint(strXPath + " " + domCell.nodeName);
            if (valtype(ar[i])!=V_UNDEF)
                domCell.text=XML_EscapeSting(ar[i]);
            end;
        end;
        iRow=iRow+1;
    end; /* macro WriteRow */

    macro SetSectionBaseName
        var i;

        for(i,StrLen(strSectionName),0,-1)
            if (StrIsNumber(SubStr(strSectionName,i)))
            else
                strSectionBaseName=SubStr(strSectionName,1,i);
                return;
            end;
        end;
        strSectionBaseName="Section";
    end; /* macro SetSectionBaseName */

    private macro SectionRename
        /* <text:section text:name="Шублон" text:style-name="Sect1"> */
        domSectionNode.setAttribute("text:name")=strSectionBaseName+String(iSection);
    end; /* macro SectionRename */

    /* определяет раздел-шаблон */
    macro Section(sParamName)
        var strXPath:String;

        if (not InitOk) return false; end;

        if ((valtype(sParamName)!=V_UNDEF) and (sParamName!=""))
            strSectionName=sParamName;
        end;

        /* <text:section text:name="Шублон" text:style-name="Sect1"> */
        strXPath="//text:section[@text:name='"+strSectionName+"']";
        domSectionNode=DOMDoc.documentElement.selectNodes(strXPath).Item(0);
        DebugPrint(domSectionNode.nodeName);
        domSectionNewNode=domSectionNode.cloneNode(true);

        SetSectionBaseName();
    end; /* macro Section */

    /* копирует ранее определённый раздел-шаблон */
    macro SectionNew()
        if (ValType(domSectionNewNode)==V_UNDEF)
            return false;
        end;
        var domSectionInsertedNode=domSectionNode.parentNode.insertBefore(domSectionNewNode.cloneNode(true),domSectionNode.nextSibling);
        domSectionNode=domSectionInsertedNode;
    end; /* macro SectionNew() */

    /* для таблиц внутри раздела добаввляет спереди имя раздела */
    private macro SectionTableRename
        var strXPath="table:table";
        var domSectionTables=domSectionNode.selectNodes(strXPath);
        var i;
        var strName;
        for(i,0,domSectionTables.length-1,1)
            strName=domSectionTables.Item(i).getAttribute("table:name");
            strName=domSectionNode.getAttribute("text:name") + " " + strName;
            domSectionTables.Item(i).setAttribute("table:name", strName);
        end;
    end; /* macro SectionTableRename */

    /*  */
    macro SetSectionFields()
        aSectionFields=TArray(Parmcount());
        var i:integer;

        for (i, 1, Parmcount()-1, 1)
            GetParm(i,aSectionFields[i-1]);
        end;
    end;


    /* изменяет названия пользовательских полей в контексте раздела */
    private macro SectionFieldsRename()
        if (not IsEqClass ("TArray", aSectionFields))    
            return false; 
        end;
        var strXPath;
        var i, j;
        var domNode, domNodes;
        /**/
        for (i, 0, aSectionFields.Size-1, 1)

            strXPath=".//text:user-field-get[@text:name='"+aSectionFields(i)+"']";
            DebugPrint(strXPath);
            domNodes=domSectionNode.selectNodes(strXPath);
            for (j, 0, domNodes.length-1, 1)
                DebugPrint("Found "+ j + " "+domNodes.Item(j).getAttribute("text:name"));
                domNodes.Item(j).setAttribute("text:name", domSectionNode.getAttribute("text:name")+"_"+aSectionFields(i));
            end;

            strXPath="//text:user-field-decl[@text:name='"+aSectionFields(i)+"']";
            domNode=domDoc.documentElement.selectNodes(strXPath).Item(0);
            var domNewVar=domNode.parentNode.appendChild(domNode.cloneNode(true));
            domNewVar.setAttribute("text:name", domSectionNode.getAttribute("text:name")+"_"+aSectionFields(i));
            
        end;
    end; /* macro SectionFieldsRename */


    /* вызывать в начале тела цикла вывода раздела */
    macro SectionAdd
        if (0==iSection)
        /* первый раздел. используется тот, что есть */
            iSection=1;
        else
        /* не первый раздел. вставляется новый       */
            SectionNew();
            iSection=iSection+1;
        end;
        SectionRename();
        SectionTableRename();
        SectionFieldsRename();
    end; /* macro SectionAdd */


    macro Destructor()

        if (not InitOk) return; end;

        if (not bSaveCalled) 
            Save(); 
        End;
    end; /* macro Destructor */

    /* Constructor */
    InitOk=Init2(strFormPath_);
end;

class (TBaseXmlDoc) TMsDocForm(strFormPath_)
    const strNsSettings="xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:r='http://schemas.openxmlformats.org/officeDocument/2006/relationships' xmlns:m='http://schemas.openxmlformats.org/officeDocument/2006/math' xmlns:v='urn:schemas-microsoft-com:vml' xmlns:w10='urn:schemas-microsoft-com:office:word' xmlns:w='http://schemas.openxmlformats.org/wordprocessingml/2006/main' xmlns:sl='http://schemas.openxmlformats.org/schemaLibrary/2006/main'";
    var domSettings;
    var modeFieldChange=2; //how to change field in document.xml
    var sMsNs="http://schemas.openxmlformats.org/wordprocessingml/2006/main";

    macro Init2(paramInit)
        

        InitTBaseXmlDoc(paramInit);

        if(not UnZipFile("word/document.xml","word\\settings.xml"))
            return false;
        end;
        /* */

        if (not LoadXml(DOMDoc, "word\\document.xml"))
            return false;    
        end;

        DOMDoc.setProperty("SelectionLanguage",   "XPath");
        DOMDoc.setProperty("SelectionNamespaces", "xmlns:ve='http://schemas.openxmlformats.org/markup-compatibility/2006' xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:r='http://schemas.openxmlformats.org/officeDocument/2006/relationships' xmlns:m='http://schemas.openxmlformats.org/officeDocument/2006/math' xmlns:v='urn:schemas-microsoft-com:vml' xmlns:wp='http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing' xmlns:w10='urn:schemas-microsoft-com:office:word' xmlns:w='http://schemas.openxmlformats.org/wordprocessingml/2006/main' xmlns:wne='http://schemas.microsoft.com/office/word/2006/wordml'");

        //для M$Word нужен ещё один файл
        domSettings = ActiveX("MSXML.DOMDocument");
        domSettings.async = False;
        if (not LoadXml(domSettings, "word\\settings.xml"))
            return false;    
        end;
        domSettings.setProperty("SelectionLanguage",   "XPath");
        domSettings.setProperty("SelectionNamespaces", strNsSettings);

        return true;
    end; /* macro Init */

    macro SetField(strFieldName, v)
        var strValueType:String;
        var strXmlType:String;
        var strXPath:String;
        var domNodes, domNode;
        var domNewNode;
        var i,j;
        var iSubFld;
        var nodeSeparate; //<w:r w:rsidR="004B59E8"><w:fldChar w:fldCharType="separate"/>
        var nodeFildValue;

        //Возвращает атрибут для сложного поля или пусто
        macro GetFieldPart(domNode)  
            var domNodes=domNode.GetElementsByTagName("w:fldChar");
            if (domNodes.length>0)
                return  domNodes.item(0).GetAttribute("w:fldCharType");
            end;
            return "";
        end;

        if (not InitOk) return false; end;

        // 1. Установка значения поля в Settings
        strXPath="//w:docVar[@w:name='"+strFieldName+"']";
        DebugPrint(strXPath);
        domNodes=domSettings.documentElement.selectNodes(strXPath);
        if (domNodes.length==0)
            var domParent=domSettings.documentElement.selectNodes("/w:settings/w:docVars");
            if (domParent.length==0)
                domNewNode=domSettings.createNode(XML_NODE_ELEMENT, "w:docVars",sMsNs);
                domParent=domSettings.documentElement.appendChild(domNewNode);
            else
                domParent=domParent.item(0);
            end;
            domNewNode=domSettings.createNode(XML_NODE_ELEMENT, "w:docVar",sMsNs);
            //domNewNode=domSettings.createNode(XML_NODE_ELEMENT, "test","");
            //domNewNode.setAttribute("w:name", strFieldName);
            domNode=domParent.appendChild(domNewNode);
            domNode.setAttribute("w:name", strFieldName);
        //
            //MsgBox("В шаблоне поле "+strFieldName+" не найдено ");
            //return false;
        else
            domNode=domNodes.Item(0);
        end;
        domNode.setAttribute("w:val", v);

        if  (modeFieldChange>0)
            // 2. Установка значения поля в Document
            // Если ничего не делать с документом, то при открытии поля будут "старые" и только после Cltr-A F9 они обновятся
            strXPath="//w:r[starts-with(normalize-space(w:instrText),'DOCVARIABLE "+strFieldName+" ' ) or normalize-space(w:instrText)='DOCVARIABLE "+strFieldName+"']";
            //DebugPrint(strXPath);
            //пока выбираем упрощённый вариант, инвалидиуем поля. в этом случае ворд при открытии будет спрашивать обновить? скажем ему да и поля обновятся
            //в будущем надо переписать на замену куска DOM см. http://officeopenxml.com/WPfields.php
            var domNodesBegin;
            var domNodesSeparate;
            domNodes=domDoc.documentElement.selectNodes(strXPath);
            if (domNodes.length==0) DebugPrint("Can not find Field \""+strFieldName+"\", using xpath "+strXPath); end;
            for (i, 0, domNodes.length-1, 1)
                iSubFld=0;
                if(1==modeFieldChange)
                    strXPath="preceding-sibling::w:r/w:fldChar[@w:fldCharType='begin' and last()]";  //последний 
                    domNodesBegin=domNodes.item(i).selectNodes(strXPath);
                    for (j, 0, domNodesBegin.length-1, 1)
                        domNodesBegin.item(j).setAttribute("w:dirty","true");
                    end; //for j
                elif(2==modeFieldChange) 
                    //strXPath="following-sibling::";
                    strXPath="following-sibling::w:r[1][w:fldChar/@w:fldCharType='separate']";   //првый снизу separate от найденного поля
                    domNodesSeparate=domNodes.item(i).selectNodes(strXPath);
                    if (domNodesSeparate.length>0)
                        strXPath="following-sibling::*";
                        domNodesBegin=domNodesSeparate.item(0).selectNodes(strXPath);
                        for (j, 0, domNodesBegin.length-1, 1)
                            var sFieldPart =GetFieldPart(domNodesBegin.item(j));
                            if  (sFieldPart=="end")
                                if (iSubFld==0)

                                    //вставляем и закругляеся
                                    domNewNode=domDoc.createNode(XML_NODE_ELEMENT, "w:r", sMsNs);
                                    domNode=domNodesBegin.item(j).parentNode.insertBefore(domNewNode,domNodesBegin.item(j));
                                    //<w:t xml:space="preserve">Ivan </w:t>
                                    domNewNode=domDoc.createNode(XML_NODE_ELEMENT, "w:t", sMsNs);
                                    domNode=domNode.appendChild(domNewNode);
                                    domNode.SetAttribute("xml:space","preserve");
                                    domNode.text=v;

                                    break;
                                else
                                    iSubFld=iSubFld-1;
                                end;
                            elif(sFieldPart=="begin")
                                iSubFld=iSubFld+1;
                            end;
                            //чистим
                            domNodesBegin.item(j).parentNode.removeChild(domNodesBegin.item(j));

                        end; //for j 
                    else
                        DebugPrint("separate not found. i="+i);
                        /**/
                                    //вставляем после найденного поля
                                    //range и в него separate
                                    domNewNode=domDoc.createNode(XML_NODE_ELEMENT, "w:r", sMsNs);
                                    nodeSeparate=domNodes.item(i).parentNode.insertBefore(domNewNode,domNodes.item(i).nextSibling);

                                    domNewNode=domDoc.createNode(XML_NODE_ELEMENT, "w:fldChar", sMsNs);
                                    domNewNode.SetAttribute("w:fldCharType","separate");
                                    nodeSeparate.appendChild(domNewNode);

                                    //а после них range и в него значение переменной
                                    domNewNode=domDoc.createNode(XML_NODE_ELEMENT, "w:r", sMsNs);
                                    nodeFildValue=domNodes.item(i).parentNode.insertBefore(domNewNode,nodeSeparate.nextSibling);

                                    //копируем стиль
                                    domNode=domNodes.item(i).SelectSingleNode("w:rPr");
                                    if ((ValType(domNode)!=V_UNDEF) and (domNode!=NullVal))
                                        //PrintLn(GetTypeName(domNode));
                                        domNewNode=domNode.cloneNode(true);
                                        nodeFildValue.appendChild(domNewNode);
                                    else
                                        PrintLn("no style");
                                    end;

                                    domNewNode=domDoc.createNode(XML_NODE_ELEMENT, "w:t", sMsNs);
                                    domNode=nodeFildValue.appendChild(domNewNode);
                                    domNode.SetAttribute("xml:space","preserve");
                                    domNode.text=v;


                                    nodeSeparate=null;
                                    nodeFildValue=null;
                        /**/
                    end;
                end;
            end; //for i
        end;

    end; //macro SetField

    macro Save(sDestFolder)
        //bSaveCalled=True;
        //if (not InitOk) return false; end;

        domDoc.Save(strWorkDir+"\\word\\document.xml");
        domSettings.Save(strWorkDir+"\\word\\settings.xml");

        var strTermDst:String;

        if ((ValType(sDestFolder)==V_STRING) and (sDestFolder!=""))
        //режим введён для массового безинтерфейсного формирования файлов     
            var sPath=sDestFolder;
            if (DocSave(@sPath))
                return sPath;
            else
                return "";
            end;
        else
            if (DocSave(@strTermDst) and (AutoOpen or AutoPrint))
                var strArgs:String;
                strArgs=strTermDst;
                /*
                if (AutoPrint)
                //печать
                    if ((ValType(Printer)!=V_UNDEF) and (Printer!=""))
                        //на указанный принтер
                        //strArgs="-pt " +Printer+ " "+ strArgs;
                    else
                        //на принтер по умолчанию
                        //strArgs="-p" + strArgs;
                    end;
                end;
                */
                //StartProg ("$"+"swriter", strArgs, true);
            else
                return false;
            end;
        end;
        return true;
    end;




    macro Destructor()
        Save();
    end;


    /* Constructor */
    InitOk=Init2(strFormPath_);
end; //class TMsDocForm

